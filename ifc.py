#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Module ifc
This module reads image data from compensated image files (.cif files) into a tensor in python.
The cif files are generated by imaging flow cytometry (IFC) instruments by Millipore.
The image data in the tensor is then readily accessible to be fed into deep learning algorithms, such as convolutional neural networks.
@author: Minh Doan, Holger Hennig 2017
"""


import bioformats
import bioformats.formatreader
import javabridge
import numpy
import math

#javabridge.start_vm(class_path=bioformats.JARS, max_heap_size='8G')

# read cif files
def read_cif(filelist, channels=range(1,12), pad=1, classes=0, verbose=0):
    print "Reading image data from cif file into numpy tensor."
    
    # set default parameters    
    multichannel_tensors = []
    labels = []
    #channels = [0,5,6,11]
    image_size = 28

    # call bioformats reader
    for i in range(len(filelist)):
        single_channel_tensors = []
        filename = filelist[i]
        reader = bioformats.formatreader.get_image_reader("tmp", path=filename)
        image_count = javabridge.call(reader.metadata, "getImageCount", "()I")
        #channel_count = javabridge.call(reader.metadata, "getChannelCount", "(I)I", 0)
    
        for j in range(len(channels)):
    
            images = [reader.read(c=channels[j], series=image) for image in range(image_count)[::2]]
    
            if pad:
                if verbose:
                    print "Padding/cropping images for channel",channels[j]
                cropped_images_this_channel = numpy.expand_dims([__pad_or_crop(image, image_size) for image in images], axis =3)
                single_channel_tensors.append(cropped_images_this_channel)
            else:
                if verbose:
                    print "No padding"
                single_channel_tensors.append(images)
                
        #transform nested single_channel_tensor to multi_channel_tensor
        if pad:
                multichannel_tensor = numpy.concatenate((single_channel_tensors), axis = 3)
        else:
                multichannel_tensor = numpy.concatenate((single_channel_tensors))
            
        multichannel_tensors.append(multichannel_tensor)
    
        if classes:
            if verbose:
                print "Assigning labels"
            label = numpy.zeros((multichannel_tensor.shape[0],len(classes)))
            for k in range(len(classes)):
                if classes[k] in filelist[i]:
                    label[:multichannel_tensor.shape[0],k]=1
                    labels.append(label)

                    
    T = numpy.concatenate((multichannel_tensors))
    if classes:
        L = numpy.concatenate((labels))
    else:
        L = []
        
    return(T, L)
    

# make all images the same size: padding images with background noise of croppping images    
def __pad_or_crop(image, image_size):
    bigger = max(image.shape[0], image.shape[1], image_size)

    pad_x = float(bigger - image.shape[0])
    pad_y = float(bigger - image.shape[1])

    pad_width_x = (int(math.floor(pad_x / 2)), int(math.ceil(pad_x / 2)))
    pad_width_y = (int(math.floor(pad_y / 2)), int(math.ceil(pad_y / 2)))
    sample = image[int(image.shape[0]/2)-4:int(image.shape[0]/2)+4, :8]

    std = numpy.std(sample)

    mean = numpy.mean(sample)

    def normal(vector, pad_width, iaxis, kwargs):
        vector[:pad_width[0]] = numpy.random.normal(mean, std, vector[:pad_width[0]].shape)
        vector[-pad_width[1]:] = numpy.random.normal(mean, std, vector[-pad_width[1]:].shape)
        return vector

    if (image_size > image.shape[0]) & (image_size > image.shape[1]):
        return numpy.pad(image, (pad_width_x, pad_width_y), normal)
    else:
        if bigger > image.shape[1]:
            temp_image = numpy.pad(image, (pad_width_y), normal)
        else:
            if bigger > image.shape[0]:
                temp_image = numpy.pad(image, (pad_width_x), normal)
            else:
                temp_image = image
        return temp_image[int((temp_image.shape[0] - image_size)/2):int((temp_image.shape[0] + image_size)/2),int((temp_image.shape[1] - image_size)/2):int((temp_image.shape[1] + image_size)/2)]


if __name__=='__main__':
    read_cif()